#include "vram_init_data.h"

#include <algorithm>
#include <cstring>

namespace vram_init {

// -----------------------------------------------------------------------------
// Demo data
// -----------------------------------------------------------------------------

static constexpr uint16_t palettes[8][16] = {
    // Palette 0: Background/World
    {0x6CF, 0x0A0, 0x070, 0x840, 0x630, 0xC63, 0x842, 0xFC6,
     0xDA4, 0xFFF, 0xDDF, 0x4A4, 0x282, 0x6C6, 0x000, 0x6CF},
    // Palette 1: Player
    {0x000, 0x000, 0xFB8, 0xD96, 0xF00, 0xA00, 0x00F, 0x00A,
     0x630, 0x420, 0xFF0, 0xFB0, 0x0FF, 0x48F, 0xAAA, 0xF0F},
    // Palette 2: Enemy
    {0x000, 0x000, 0xA0A, 0x606, 0xFFF, 0x000, 0xFFF, 0x000,
     0x181, 0x3C3, 0xF44, 0xFF0, 0x5F5, 0x9F9, 0x070, 0xF0F},
    // Palette 3: Collectibles
    {0x000, 0x111, 0xFE0, 0xDA0, 0xA70, 0x740, 0xFFF, 0xF00,
     0xFFF, 0xFDA, 0x0F0, 0x0A0, 0xF80, 0xFF0, 0x888, 0xF0F},
    // Palettes 4–7 unused (zero)
    {0}, {0}, {0}, {0},
};

// Tiles 0–17 (18 tiles total). Each tile is 32 bytes.
static constexpr uint8_t tiles[][32] = {
    // Tile 0: Empty/Sky
    {
        0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
    },
    // Tile 1: Grass top
    {
        0x11,0x21,0x11,0x12, 0x21,0x11,0x21,0x11,
        0x11,0x11,0x11,0x11, 0x33,0x33,0x33,0x33,
        0x33,0x43,0x33,0x34, 0x43,0x33,0x43,0x33,
        0x33,0x33,0x33,0x33, 0x33,0x43,0x34,0x33,
    },
    // Tile 2: Dirt block
    {
        0x33,0x43,0x33,0x34, 0x43,0x33,0x43,0x33,
        0x33,0x33,0x33,0x33, 0x34,0x43,0x33,0x43,
        0x33,0x33,0x43,0x33, 0x43,0x34,0x33,0x34,
        0x33,0x33,0x33,0x33, 0x34,0x33,0x43,0x33,
    },
    // Tile 3: Brick block
    {
        0xE5,0x55,0x5E,0x55, 0x55,0x55,0x55,0x55,
        0x55,0x56,0x65,0x56, 0xEE,0xEE,0xEE,0xEE,
        0x55,0xE5,0x55,0x5E, 0x55,0x55,0x55,0x55,
        0x56,0x55,0x65,0x55, 0xEE,0xEE,0xEE,0xEE,
    },
    // Tile 4: Question block
    {
        0xEE,0xEE,0xEE,0xEE, 0xE7,0x77,0x77,0x7E,
        0xE7,0xE7,0x7E,0x7E, 0xE7,0x7E,0xE7,0x7E,
        0xE7,0x77,0xE7,0x7E, 0xE7,0x77,0x77,0x7E,
        0xE7,0x77,0xE7,0x7E, 0xE8,0x88,0x88,0x8E,
    },
    // Tile 5: Cloud left
    {
        0x00,0x00,0x09,0x90, 0x00,0x09,0x99,0x99,
        0x09,0x99,0x99,0x99, 0x99,0x99,0x99,0x99,
        0x99,0x99,0x99,0x99, 0x0A,0x99,0x99,0x99,
        0x00,0x0A,0xAA,0x99, 0x00,0x00,0x00,0x0A,
    },
    // Tile 6: Cloud right
    {
        0x09,0x90,0x00,0x00, 0x99,0x99,0x90,0x00,
        0x99,0x99,0x99,0x90, 0x99,0x99,0x99,0x99,
        0x99,0x99,0x99,0x99, 0x99,0x99,0x9A,0x00,
        0x9A,0xAA,0xA0,0x00, 0xA0,0x00,0x00,0x00,
    },
    // Tile 7: Pipe top left
    {
        0xEC,0xDD,0xBB,0xBB, 0xEB,0xDB,0xBB,0xBB,
        0xEB,0xDB,0xBB,0xBB, 0xEC,0xCC,0xCC,0xCC,
        0x0E,0xDB,0xBB,0xBB, 0x0E,0xDB,0xBB,0xBB,
        0x0E,0xDB,0xBB,0xBB, 0x0E,0xDB,0xBB,0xBB,
    },
    // Tile 8: Pipe top right
    {
        0xBB,0xBB,0xCC,0xCE, 0xBB,0xBB,0xBC,0xBE,
        0xBB,0xBB,0xBC,0xBE, 0xCC,0xCC,0xCC,0xCE,
        0xBB,0xBB,0xCE,0x0E, 0xBB,0xBB,0xCE,0x0E,
        0xBB,0xBB,0xCE,0x0E, 0xBB,0xBB,0xCE,0x0E,
    },
    // Tile 9: Pipe body left
    {
        0x0E,0xDB,0xBB,0xBB, 0x0E,0xDB,0xBB,0xBB,
        0x0E,0xDB,0xBB,0xBB, 0x0E,0xDB,0xBB,0xBB,
        0x0E,0xDB,0xBB,0xBB, 0x0E,0xDB,0xBB,0xBB,
        0x0E,0xDB,0xBB,0xBB, 0x0E,0xDB,0xBB,0xBB,
    },
    // Tile 10: Pipe body right
    {
        0xBB,0xBB,0xCE,0x0E, 0xBB,0xBB,0xCE,0x0E,
        0xBB,0xBB,0xCE,0x0E, 0xBB,0xBB,0xCE,0x0E,
        0xBB,0xBB,0xCE,0x0E, 0xBB,0xBB,0xCE,0x0E,
        0xBB,0xBB,0xCE,0x0E, 0xBB,0xBB,0xCE,0x0E,
    },
    // Tile 11: Bush left
    {
        0x00,0x00,0x01,0x10, 0x00,0x01,0x11,0x11,
        0x01,0x11,0x21,0x11, 0x11,0x12,0x11,0x21,
        0x11,0x11,0x11,0x11, 0x12,0x11,0x21,0x11,
        0x02,0x22,0x12,0x21, 0x00,0x02,0x22,0x22,
    },
    // Tile 12: Bush right
    {
        0x01,0x10,0x00,0x00, 0x11,0x11,0x10,0x00,
        0x11,0x12,0x11,0x10, 0x12,0x11,0x21,0x11,
        0x11,0x11,0x11,0x11, 0x11,0x12,0x11,0x21,
        0x12,0x21,0x22,0x20, 0x22,0x22,0x20,0x00,
    },
    // Tile 13: Human (Head/Torso)
    {
        0xFF,0x88,0x88,0xFF, 0xFF,0x88,0x88,0xFF,
        0xFF,0x22,0x22,0xFF, 0xFF,0x22,0x22,0xFF,
        0xFF,0x44,0x44,0xFF, 0xFF,0x44,0x44,0xFF,
        0xFF,0x44,0x44,0xFF, 0xFF,0x44,0x44,0xFF,
    },
    // Tile 14: Human (Legs)
    {
        0xFF,0x66,0x66,0xFF, 0xFF,0x66,0x66,0xFF,
        0xFF,0x66,0x66,0xFF, 0xFF,0x66,0x66,0xFF,
        0xFF,0x66,0x66,0xFF, 0xFF,0x66,0x66,0xFF,
        0xFF,0x11,0x11,0xFF, 0xFF,0x11,0x11,0xFF,
    },
    // Tile 15: Blob Enemy (upper)
    {
        0xFF,0xFF,0xFF,0xFF, 0xFF,0x22,0x22,0xFF,
        0xF2,0x22,0x22,0x2F, 0x22,0x22,0x22,0x22,
        0x22,0x42,0x24,0x22, 0x22,0x42,0x24,0x22,
        0x22,0x22,0x22,0x22, 0x22,0x22,0x22,0x22,
    },
    // Tile 16: Blob Enemy (lower)
    {
        0x22,0x22,0x22,0x22, 0x22,0x22,0x22,0x22,
        0x22,0x22,0x22,0x22, 0xF2,0x22,0x22,0x2F,
        0xFF,0x22,0x22,0xFF, 0xFF,0xFF,0xFF,0xFF,
        0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF,
    },
    // Tile 17: Coin
    {
        0xFF,0x23,0x32,0xFF, 0xF2,0x62,0x24,0x3F,
        0x26,0x22,0x22,0x43, 0x22,0x22,0x22,0x44,
        0x22,0x22,0x22,0x44, 0x32,0x22,0x24,0x43,
        0xF3,0x22,0x44,0x4F, 0xFF,0x34,0x43,0xFF,
    },
};

// OAM entries we care about; others are zeroed.
static constexpr uint32_t oam_entries[128] = {
    // 0
    0x841B6050, // Robot upper (tile 13, palette 1) at (80,176)
    0x841D7050, // Robot lower (tile 14, palette 1) at (80,184)
    0x881F60A0, // Slime upper (tile 15, palette 2) at (160,176)
    0x00000000, // 3
    0x00000000, // 4
    0x00000000, // 5
    0x8C22F064, // Coin (tile 17, palette 3) at (100,120)
    0x8C22F074, // Coin (tile 17, palette 3) at (116,120)
    0x8C22F084, // Coin (tile 17, palette 3) at (132,120)
    0x8C22A0C8, // Coin (tile 17, palette 3) at (200,80)
    0x8C22A0D8, // Coin (tile 17, palette 3) at (216,80)
    // rest default to 0
};

// -----------------------------------------------------------------------------
// Helpers
// -----------------------------------------------------------------------------

static inline void clear_range(uint8_t* ram, std::size_t ram_size, uint32_t base, uint32_t len) {
    if (!ram) return;
    if (base >= ram_size) return;
    uint32_t clamped = (base + len > ram_size) ? (ram_size - base) : len;
    std::memset(ram + base, 0, clamped);
}

static inline void write16le(uint8_t* dst, uint16_t v) {
    dst[0] = static_cast<uint8_t>(v & 0xFF);
    dst[1] = static_cast<uint8_t>((v >> 8) & 0xFF);
}

// -----------------------------------------------------------------------------
// Public API
// -----------------------------------------------------------------------------

void load(uint8_t* ram, std::size_t ram_size) {
    if (!ram || ram_size == 0) return;

    // Clear VRAM-reserved ranges for determinism
    clear_range(ram, ram_size, Layout::palette_base, Layout::palette_bytes);
    clear_range(ram, ram_size, Layout::tile_base, Layout::tile_bytes);
    clear_range(ram, ram_size, Layout::bg_map_base, Layout::bg_map_bytes);
    clear_range(ram, ram_size, Layout::ui_map_base, Layout::ui_map_bytes);
    clear_range(ram, ram_size, Layout::oam_base, Layout::oam_bytes);

    // Palettes
    for (int p = 0; p < Params::palette_count; ++p) {
        for (int c = 0; c < Params::colors_per_palette; ++c) {
            uint32_t off = Layout::palette_base + static_cast<uint32_t>((p * Params::colors_per_palette + c) * Params::bytes_per_color);
            if (off + 1 >= ram_size) continue;
            write16le(ram + off, palettes[p][c]);
        }
    }

    // Tiles
    const int tile_count = static_cast<int>(sizeof(tiles) / sizeof(tiles[0]));
    for (int t = 0; t < tile_count; ++t) {
        uint32_t off = Layout::tile_base + static_cast<uint32_t>(t * Params::bytes_per_tile);
        if (off + Params::bytes_per_tile > ram_size) break;
        std::memcpy(ram + off, tiles[t], Params::bytes_per_tile);
    }

    // BG map (64x64), default 0 = sky
    auto set_bg = [&](int x, int y, uint8_t v) {
        if (x < 0 || x >= Params::bg_map_w_tiles || y < 0 || y >= Params::bg_map_h_tiles) return;
        uint32_t off = Layout::bg_map_base + static_cast<uint32_t>(y * Params::bg_map_w_tiles + x);
        if (off < ram_size) ram[off] = v;
    };

    // Ground layer: row 24 grass (tile 1), rows 25–29 dirt (tile 2) for x=0..39
    for (int x = 0; x < 40; ++x) {
        set_bg(x, 24, 1);
        for (int y = 25; y <= 29; ++y) set_bg(x, y, 2);
    }

    // Floating platforms
    set_bg(12, 17, 3); set_bg(13, 17, 4); set_bg(14, 17, 3); set_bg(15, 17, 4); set_bg(16, 17, 3);
    set_bg(24, 11, 3); set_bg(25, 11, 3); set_bg(26, 11, 4); set_bg(27, 11, 3);

    // Clouds
    set_bg(5, 3, 5);  set_bg(6, 3, 6);
    set_bg(20, 4, 5); set_bg(21, 4, 6);
    set_bg(32, 2, 5); set_bg(33, 2, 6);

    // Pipe at x=35
    set_bg(35, 21, 7); set_bg(36, 21, 8);
    set_bg(35, 22, 9); set_bg(36, 22, 10);
    set_bg(35, 23, 9); set_bg(36, 23, 10);

    // Bushes row 23
    set_bg(3, 23, 11);  set_bg(4, 23, 12);
    set_bg(15, 23, 11); set_bg(16, 23, 12);
    set_bg(28, 23, 11); set_bg(29, 23, 12);

    // UI map 40x10 filled with 0x11
    for (int y = 0; y < Params::ui_map_h_tiles; ++y) {
        for (int x = 0; x < Params::ui_map_w_tiles; ++x) {
            uint32_t off = Layout::ui_map_base + static_cast<uint32_t>(y * Params::ui_map_w_tiles + x);
            if (off < ram_size) ram[off] = 0x11;
        }
    }

    // OAM
    const int oam_defined = static_cast<int>(sizeof(oam_entries) / sizeof(oam_entries[0]));
    for (int i = 0; i < oam_defined; ++i) {
        uint32_t off = Layout::oam_base + static_cast<uint32_t>(i * Params::bytes_per_oam);
        if (off + 3 >= ram_size) break;
        uint32_t v = oam_entries[i];
        ram[off + 0] = static_cast<uint8_t>(v & 0xFF);
        ram[off + 1] = static_cast<uint8_t>((v >> 8) & 0xFF);
        ram[off + 2] = static_cast<uint8_t>((v >> 16) & 0xFF);
        ram[off + 3] = static_cast<uint8_t>((v >> 24) & 0xFF);
    }
}

void load(std::vector<uint8_t>& ram) {
    load(ram.data(), ram.size());
}

} // namespace vram_init
